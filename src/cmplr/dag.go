// Â© Knug Industries 2009 all rights reserved 
// GNU GENERAL PUBLIC LICENSE VERSION 3.0
// Author bjarneh@ifi.uio.no

package dag

import(
    "container/vector";
    "utilz/stringset";
    "utilz/stringbuffer";
    "go/parser";
    "path";
    "go/ast";
    "os";
    "fmt";
    "time";
)


type Dag struct{
    pkgs map[string] *Package; // package-name -> Package object
}

type Package struct{
    indegree int;
    Name, ShortName string;
    Files *vector.StringVector; // relative path of files
    dependencies *stringset.StringSet;
    children *vector.Vector; // packages that depend on this
}

type TestCollector struct{
    Names *vector.StringVector;
}

func New() *Dag{
    d := new(Dag);
    d.pkgs = make(map[string]*Package);
    return d;
}

func newPackage() *Package{
    p := new(Package);
    p.indegree = 0;
    p.Files = new(vector.StringVector);
    p.dependencies = stringset.New();
    p.children = new(vector.Vector);
    return p;
}

func newTestCollector() *TestCollector{
    t := new(TestCollector);
    t.Names = new(vector.StringVector);
    return t;
}

func (d *Dag) Parse(root string, sv *vector.StringVector){

    root = addSeparatorPath(root);

    for e := range sv.Iter() {

        tree := getSyntaxTreeOrDie(e, parser.ImportsOnly);
        dir, _ := path.Split(e);
        unroot := dir[len(root):len(dir)];
        pkgname := path.Join(unroot, tree.Name.Obj.Name);

        _, ok := d.pkgs[pkgname];
        if ! ok {
            d.pkgs[pkgname] = newPackage();
            d.pkgs[pkgname].Name = pkgname;
            d.pkgs[pkgname].ShortName = tree.Name.Obj.Name;
        }

        ast.Walk( d.pkgs[pkgname], tree );
        d.pkgs[pkgname].Files.Push(e);
    }
}

func (d *Dag) addEdge(from, to string){
    fromNode := d.pkgs[from];
    toNode   := d.pkgs[to];
    fromNode.children.Push(toNode);
    toNode.indegree++;
}
// note that nothing is done in order to check if dependencies
// are valid if they are not part of the actual source-tree,
// i.e., stdlib dependencies and included (-I) dependencies
// are not investigated for validity..
func (d *Dag) GraphBuilder(includes []string){

    goRoot := path.Join(os.Getenv("GOROOT"), "src/pkg");

    for k,v := range d.pkgs {

        for dep := range v.dependencies.Iter() {

            if d.localDependency(dep) {
                d.addEdge(dep, k);
///                 fmt.Printf("local:  %s \n", dep);
            }else if ! d.stdlibDependency(goRoot, dep) {
                if includes == nil || len(includes) > 0 {
                    fmt.Fprintf(os.Stderr,"[ERROR] Dependency: %s not found\n",dep);
                    fmt.Fprintf(os.Stderr,"[ERROR] Did you use actual src-root?\n");
                    os.Exit(1);
                }
            }
        }
    }
}

func (d *Dag) MakeMainTest(root string) (*vector.Vector, string){

    var max, rwxr_xr_x int;
    var isTest bool;
    var sname, tmpdir, tmpstub, tmpfile string;
    rwxr_xr_x = 493;

    sbImports := stringbuffer.NewSize(300);
    sbTests   := stringbuffer.NewSize(1000);
    sbBench   := stringbuffer.NewSize(1000);

    sbImports.Add("\n// autogenerated code\n\n");
    sbImports.Add("package main\n\n");
    sbImports.Add("import \"testing\";\n");

    sbTests.Add("\n\nvar tests = []testing.Test{\n");
    sbBench.Add("\n\nvar benchmarks = []testing.Benchmark{\n");


    for _, v := range d.pkgs {

        isTest = false;
        sname = v.ShortName;
        max = len(v.ShortName);

        if max > 5 && sname[max-5:] == "_test" {
            collector := newTestCollector();
            for elm := range v.Files.Iter() {
                tree := getSyntaxTreeOrDie(elm, 0);
                ast.Walk( collector, tree );
            }

            if collector.Names.Len() > 0 {
                isTest = true;
                sbImports.Add(fmt.Sprintf("import \"%s\";\n", v.Name));
                for testFunc := range collector.Names.Iter() {
                    if len(testFunc) > 4 && testFunc[0:4] == "Test" {
                        sbTests.Add(fmt.Sprintf("testing.Test{\"%s.%s\", %s.%s },\n",
                                                sname, testFunc, sname, testFunc));
                    }else if len(testFunc) > 9 && testFunc[0:9] == "Benchmark" {
                        sbBench.Add(fmt.Sprintf("testing.Benchmark{\"%s.%s\", %s.%s },\n",
                                                sname, testFunc, sname, testFunc));

                    }
                }
            }
        }

        if ! isTest {

            collector := newTestCollector();

            for fname := range v.Files.Iter() {
                if len(fname) > 8 && fname[len(fname)-8:] == "_test.go"{
                    tree := getSyntaxTreeOrDie(fname, 0);
                    ast.Walk( collector, tree );
                }
            }

            if collector.Names.Len() > 0 {
                sbImports.Add(fmt.Sprintf("import \"%s\";\n", v.Name));
                for testFunc := range collector.Names.Iter() {
                    if len(testFunc) > 4 && testFunc[0:4] == "Test" {
                        sbTests.Add(fmt.Sprintf("testing.Test{\"%s.%s\", %s.%s },\n",
                                                sname, testFunc, sname, testFunc));
                    }else if len(testFunc) > 9 && testFunc[0:9] == "Benchmark" {
                        sbBench.Add(fmt.Sprintf("testing.Benchmark{\"%s.%s\", %s.%s },\n",
                                                sname, testFunc, sname, testFunc));
                    }
                }
            }
        }
    }

    sbTests.Add("};\n");
    sbBench.Add("};\n\n");

    sbTotal := stringbuffer.NewSize(sbImports.Len()+
                                    sbTests.Len()+
                                    sbBench.Len()+ 5);
    sbTotal.Add(sbImports.String());
    sbTotal.Add(sbTests.String());
    sbTotal.Add(sbBench.String());
    sbTotal.Add("func main(){\n");
    sbTotal.Add("testing.Main(tests);\n");
    sbTotal.Add("testing.RunBenchmarks(benchmarks);\n}\n\n");

    tmpstub = fmt.Sprintf("tmp%d", time.Seconds());
    tmpdir  = fmt.Sprintf("%s%s", addSeparatorPath(root), tmpstub);

    dir, e1 := os.Stat(tmpdir);

    if e1 == nil && dir.IsDirectory() {
        fmt.Fprintf(os.Stderr,"[ERROR] directory: %s already exists\n",tmpdir);
    }else{
        e_mk := os.Mkdir(tmpdir, rwxr_xr_x);
        if e_mk != nil {
            fmt.Fprintf(os.Stderr,"[ERROR] failed to create directory for testing\n");
            os.Exit(1);
        }
    }

    tmpfile = path.Join(tmpdir, "main.go");

    fil, e2 := os.Open(tmpfile, os.O_WRONLY | os.O_CREAT, rwxr_xr_x);

    if e2 != nil {
        fmt.Fprintf(os.Stderr, "[ERROR] %s\n", e2);
        os.Exit(1);
    }

    n, e3 := fil.WriteString(sbTotal.String());

    if e3 != nil {
        fmt.Fprintf(os.Stderr,"[ERROR] %s\n", e3);
        os.Exit(1);
    }else if n != sbTotal.Len(){
        fmt.Fprintf(os.Stderr,"[ERROR] failed to write test\n");
        os.Exit(1);
    }

    fil.Close();

    p := newPackage();
    p.Name = tmpstub +"/main";
    p.ShortName = "main";
    p.Files.Push(tmpfile);

    vec := new(vector.Vector);
    vec.Push(p);
    return vec, tmpdir;
}

func (d *Dag) Topsort() *vector.Vector{

    var node,child *Package;
    var cnt int = 0;

    zero := new(vector.Vector);
    done := new(vector.Vector);

    for _,v := range d.pkgs {
        if v.indegree == 0 {
            zero.Push(v);
        }
    }

    for zero.Len() > 0 {

        node,_ = zero.Pop().(*Package);

        for ch := range node.children.Iter() {
            child = ch.(*Package);
            child.indegree--;
            if child.indegree == 0 {
                zero.Push(child);
            }
        }
        cnt++;
        done.Push(node);
    }

    if cnt < len(d.pkgs) {
        fmt.Fprintf(os.Stderr,"[ERROR] loop in dependency graph\n");
        os.Exit(1);
    }

    return done;
}

func (d *Dag) localDependency(dep string) bool{
    _, ok := d.pkgs[dep];
    return ok;
}

func (d *Dag) stdlibDependency(root, dep string) bool{
    dir, staterr := os.Stat(path.Join(root, dep));
    if staterr != nil { return false; }
    return dir.IsDirectory();
}

func (d *Dag) PrintInfo(){

    fmt.Println("--------------------------------------");
    fmt.Println("Packages and Dependencies");
    fmt.Println("p = package, f = file, d = dependency ");
    fmt.Println("--------------------------------------\n");

    for k,v := range d.pkgs {
        fmt.Println("p ",k);
        for fs := range v.Files.Iter() {
            fmt.Println("f ",fs);
        }
        for ds := range v.dependencies.Iter() {
            fmt.Println("d ",ds);
        }
        fmt.Println("");
    }
}


func (p *Package) Visit(node interface{}) (v ast.Visitor){

    switch node.(type){
        case *ast.BasicLit:
            bl, ok := node.(*ast.BasicLit);
            if ok{
                stripped := stripQuotes(string(bl.Value));
                p.dependencies.Add(stripped);
            }
        default: // nothing to do if not BasicLit
    }
    return p;
}

func (t *TestCollector) Visit(node interface{}) (v ast.Visitor){
    switch node.(type){
        case *ast.FuncDecl:
            fdecl, ok := node.(*ast.FuncDecl);
            if ok {
                t.Names.Push(fdecl.Name.Obj.Name);
            }
        default: // nothing to do if not FuncDecl
    }
    return t;
}

func stripQuotes(s string) string{
    stripped := s[1:(len(s) -1)];
    return stripped;
}

func addSeparatorPath(root string) string{
    if root[len(root)-1:] != "/" {
        root = root + "/";
    }
    return root;
}

func getSyntaxTreeOrDie(file string, mode uint) (*ast.File){
    absSynTree, err := parser.ParseFile(file, nil, nil, mode);
    if err != nil {
        fmt.Fprintf(os.Stderr, "%s\n", err);
        os.Exit(1);
    }
    return absSynTree;
}

